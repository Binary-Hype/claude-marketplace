#!/usr/bin/env node
/**
 * exempt-secret - Grant temporary session-scoped access to a secret file.
 *
 * Usage: exempt-secret <file_path_or_basename> [file2] ...
 *
 * Called by Claude after user approval. Adds paths to the session override
 * file so protect-secrets.js allows access. Session-scoped only â€” stored
 * in /tmp, lost on reboot. This is intentional: prompt injection can't
 * create permanent security holes.
 */

const fs = require('fs');
const path = require('path');

const PREFIX = '[protect-secrets]';

function getCacheDir() {
  if (process.env.CLAUDE_SECURITY_CACHE_DIR) {
    return process.env.CLAUDE_SECURITY_CACHE_DIR;
  }
  const uid = process.getuid ? process.getuid() : 'default';
  return `/tmp/claude-security-${uid}`;
}

function main() {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.error(`${PREFIX} Usage: exempt-secret <file_path_or_basename> [file2] ...`);
    process.exit(1);
  }

  const cacheDir = getCacheDir();

  if (!fs.existsSync(cacheDir)) {
    fs.mkdirSync(cacheDir, { recursive: true, mode: 0o700 });
  }

  const overrideFile = path.join(cacheDir, 'secret-overrides');

  // Load existing overrides
  const existing = new Set();
  try {
    if (fs.existsSync(overrideFile)) {
      fs.readFileSync(overrideFile, 'utf8')
        .split('\n')
        .filter(Boolean)
        .forEach((entry) => existing.add(entry));
    }
  } catch {
    // Ignore read errors
  }

  const newEntries = [];

  for (const entry of args) {
    if (existing.has(entry)) {
      console.log(`${PREFIX} Already exempted: ${entry}`);
      continue;
    }

    newEntries.push(entry);
    existing.add(entry);
    console.log(`${PREFIX} Granted session access to: ${entry}`);
  }

  // Append new entries
  if (newEntries.length > 0) {
    fs.appendFileSync(overrideFile, newEntries.join('\n') + '\n', 'utf8');
  }

  console.log(`${PREFIX} Done. Secret file(s) exempted for this session only.`);
}

main();
